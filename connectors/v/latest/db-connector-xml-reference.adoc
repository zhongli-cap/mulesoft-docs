= Database Connector XML Reference

The Database connector has a single configuration that accommodates child elements that define providers, as shown in the following examples:

* `<db:generic-connection url="jdbc:derby:muleEmbeddedDB;create=true" driverClassName="org.apache.derby.jdbc.EmbeddedDriver"/>`
* `<db:my-sql-connection  host="0.0.0.0" port="3306" user="Max" password="POWERS" database="someSchema"/>`
* `<db:derby-connection database="target/muleEmbeddedDB" create="true">`
* `<db:oracle-connection host="192.168.99.100" port="1521" instance="xe" user="system" password="oracle" />`

The Database Connector Technical Reference describes exclusive and common parameters for each provider. A child element of the provider element defines custom data types. For example:

[source,xml,linenums]
----
<db:config name="dbConfig">
   <db:derby-connection url="jdbc:derby:muleEmbeddedDB;create=true">
       <db:custom-data-types>
           <!-- Derby uses JAVA_OBJECT for UDT-->
           <db:custom-data-type typeName="CONTACT_DETAILS" id="2000"/>
       </db:custom-data-types>
   </db:derby-connection>
</db:config>
----

== Operations

The database connector supports the following SQL queries:

* Delete
* Insert
* Select
* Update

=== Select Operation

The Select operation returns one of the following types, depending on streaming:

* List of Map<String, Object> (no streaming)
* Iterator

If the results are streamed, the connection and its underlying resources are not released until the returned stream is fully consumed or the flow ends.

The following examples shows the syntax of a select operation:

[source,xml,linenums]
----
<db:select maxRows="2">
  <db:sql>SELECT * FROM planet ORDER BY Id</db:sql>
</db:select>
----

=== Parametrized Queries

Queries can include parameters.  Parametrized queries are parameters you reference and set by name. You can use a colon (:) to reference a parameter by name. To include parameters in queries, use parametrized queries instead of dynamic queries for the following reasons:

* Immunity from SQL injection attacks
* Performance

You can use input parameters only in a WHERE clause. For example, use the colon syntax in a parametrized query as follows:

[source,xml,linenums]
----
<flow name="selectParameterizedQuery">
   <db:select config-ref="dbConfig">
       <db:sql>select * from PLANET where name = :name</db:sql>
       <db:input-parameters>
           #[{'name' : payload}]
       </db:input-parameters>
   </db:select>
</flow>
----

This operation uses DataWeave to supply the parameters.

=== Insert Operation

The following example shows the syntax of an insert operation:

[source,xml,linenums]
----
<db:insert config-ref="dbConfig">
  <db:sql>
      INSERT INTO PLANET(POSITION, NAME, DESCRIPTION) VALUES (777, 'Pluto', :description)
  </db:sql>
   <db:input-parameters>
       #[
           {'description' : payload}
       ]
   </db:input-parameters>
</db:insert>

----

=== Update Operation

The following example shows the syntax of an update operation:

[source,xml,linenums]
----
<db:update config-ref="dbConfig">
  <db:sql>
      UPDATE PLANET SET DESCRIPTION = :description where POSITION = :position
  </db:sql>
   <db:input-parameters>
       #[
           {'description' : payload,
     'position' : 7,
    }
       ]
   </db:input-parameters>
</db:update>
----

=== Delete Operation

The following example shows the syntax of a delete operation.

[source,xml,linenums]
----
<db:delete config-ref="dbConfig">
  <db:sql>
      DELETE FROM PLANET where POSITION = :position
  </db:sql>
   <db:input-parameters>
       #[
           {'position' : 7}
       ]
   </db:input-parameters>
</db:insert>
----

////
=== Hybrid Queries

You can mix dynamic and parametrized queries. For example:

[source,xml,linenums]
----
<flow name="selectHybridQuery">
  <set-variable variableName="tableName" value="PLANET"/>
  <db:select>
    <db:sql>SELECT * FROM #[tableName] WHERE Name = :name</db:sql>
      <db:input-parameters>
        <db:input-parameter key="name" value="#[payload]"/>
      </db:input-parameters>
  </db:select>
</flow>
----


Do _not_ swap the position of the dynamic and parametrized query because the dynamic `#[tableName]` construct misplaced in the WHERE clause makes the code vulnerable to SQL injection. 
////

=== Stored Procedures

This operation accepts input, output, and input-output parameters. 

*Input Parameters Example*

[source,xml,linenums]
----
<db:stored-procedure config-ref="dbConfig">
   <db:sql>call updatePlanetDescription('Venus', :description)</db:sql>
   <db:parameter-types>
       <db:parameter-type key="description" type="CLOB" />
   </db:parameter-types>
   <db:input-parameters>
       #[{'description' : payload}]
   </db:input-parameters>
</db:stored-procedure>
----

*Output Parameters Example*

[source,xml,linenums]
----
<db:stored-procedure config-ref="dbConfig">
   <db:sql>{ CALL countTestRecords(:count) }</db:sql>
   <db:output-parameters>
       <db:output-parameter key="count"/>
   </db:output-parameters>
</db:stored-procedure>
----

*Input-output Parameters*

[source,xml,linenums]
----
<db:stored-procedure config-ref="dbConfig">
   <db:sql>{ call doubleMyInt(:myInt) }</db:sql>
   <db:in-out-parameters>
       <db:in-out-parameter key="myInt" value="3"/>
   </db:in-out-parameters>
</db:stored-procedure>
----

DataSense is not supported when you work with stored procedures because the return value is unpredictable.

////
You can reuse a stored procedure as shown in the following example:

[source,xml,linenums]
----
<db:stored-procedure name=”split” streaming="true">
   <db:sql>{ call getSplitTestRecords() }</db:sql>
</db:stored-procedure>

<flow name="getResultSet">
   <db:stored-procedure template=”split” />
</flow>
----
////

=== Execute DDL

This operation supports any DDL statement you can run on the database connected to Mule. For example, you can create, alter, or drop a table using this operation. For example:

[source,xml,linenums]
----
<db:execute-ddl config-ref="dbConfig" queryTimeout="10" queryTimeoutUnit="SECONDS">
   <db:sql>
       create TABLE patients (
           PATIENT_ID integer NOT NULL UNIQUE,
           FIRST_NAME varchar(255),
           LAST_NAME varchar(800),
           PHONE varchar(20),
           DATE_OF_BIRTH varchar(20),
           GENDER varchar(1))
   </db:sql>
</db:execute-ddl>
----

=== Bulk Operations

Using these operations, you can execute multiple statements in a single database call, which typically improves performance. The database connector supports the following operations:

* Bulk insert
* Bulk update
* Bulk delete

Bulk insert executes an insert statement multiple times using different parameter bindings. For example:

[source,xml,linenums]
----
<flow name="bulkInsert">
   <db:bulk-insert parameterValues="#[payload]">
       <db:sql>INSERT INTO planet(Position, Name) VALUES (777, :name)</db:sql>
   </db:bulk-insert>
</flow>
----

You do not need to provide the `input-parameters` element to bind the `:name` parameter. The parameterValues (List<Map<String, Object>>
) attribute provides the information for this binding. You can force the database type of a single parameter, but this is optional and typically unnecessary. For example:

[source,xml,linenums]
----
<flow name="bulkInsertWithOverriddenType">
   <db:bulk-insert parameterValues="#[payload]">
       <db:sql>INSERT INTO planet(Position, Name) VALUES (777, :name)</db:sql>
       <db:parameter-types>
           <db:parameter-type key="name" type="VARCHAR" />
       </db:parameter-types>
   </db:bulk-insert>
</flow>
----

The following examples show the bulk update and bulk delete operations.

*Update*

[source,xml,linenums]
----
<flow name="bulkUpdate">
   <db:bulk-delete parameterValues="#[payload]">
       <db:sql>DELETE FROM planet WHERE Name = :name</db:sql>
   </db:bulk-delete>
</flow>
----

*Update*

[source,xml,linenums]
----
<flow name="bulkDelete">
   <db:bulk-update parameterValues="#[payload]">
       <db:sql>UPDATE planet SET Name = 'Mercury' WHERE Name = :name</db:sql>
   </db:bulk-update>
</flow>
----

=== Execute Script

The execute-script operation runs any script that does not involve a SQL projection. You can use execute-script in the following ways:

* Embed execute-script in an operation.
* Reference execute-script from a file. 

You cannot use both ways of executing a script at the same time.

*Embed in an Operation*

[source,xml,linenums]
----
<flow name="executeScript">
   <db:execute-script>
       <db:sql>
           UPDATE planet SET Name='Mercury' WHERE Position=0;
           UPDATE planet SET Name='Mercury' WHERE Position=4;
       </db:sql>
   </db:execute-script>
</flow>
----

*Reference from a File*

[source,xml,linenums]
----
<flow name="executeScriptFromFile">
   <db:execute-script file="integration/executescript/bulk-script.sql" />
</flow>
----

== Formatting the Output of a Query

The db:output-parameter converts the output of a query from binary to a JDBC or custom type, such as JSON. For example:

`<db:output-parameter paramName="myParam" type="VARCHAR"/>`


== See Also

link:/connectors/database-documentation[Database Connector Technical Reference]