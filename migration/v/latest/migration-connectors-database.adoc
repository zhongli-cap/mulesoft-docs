// sme: MG, author: sduke?
= Migrating the Database Connector

// Explain generally how and why things changed between Mule 3 and Mule 4.
The Database connector for Mule 4 can connect to any relational database engine. Here are the main changes for Mule 4:

 ** All database processes (such as Select, Insert, Update, Delete, and others) have been refactored into separate operations. There are also new, dedicated bulk operations for Mule 4.
 ** Use of DataWeave: Database operations, such as Insert and Update, support DataWeave version 2 transformations. You can construct the data sets that insert or update the database without message side effects, and you no longer use message enrichers.
* You can perform dynamic and static queries in similar ways.
* The Mule streaming framework is automatically configured for your operations. You can execute a select statement and process the results asynchronously without worrying about leaking connections.

== What's Covered Here?

* <<database_configuration>>
* <<database_operation_select>>
* <<database_dynamic_queries>>
* <<database_streaming>>
* <<database_operation_bulk>>

[[database_configuration]]
== Database Configuration

// TODO: EXPLAIN CONFIG CHANGES?
The connectors for Mule 3 and Mule 4 supports Derby, MySQL, Oracle, and generic database configurations. For Mule 4, Microsoft SQL Server is also and Data Source Reference connections are also supported. The XML for these configurations has changed in Mule 4.

Most database connection configurations are set under the same top-level element in Mule 4. An exception is the Data Source Reference Connection.

`<db:config />` is the top-level element for all database connection configurations in Mule 4, and specific database configurations are nested under separate `<db:config />` elements:

* Derby: `<db:data-source-connection />`
* Microsoft SQL Server: `<db:mssql-connection />`
* MySql: `<db:my-sql-connection />`
* Oracle: `<db:oracle-connection />`
* Generic: `<db:generic-connection />`
* Data Source Reference Connection: `<db:data-source-connection />`

.Mule 3 Example: Derby Configuration
[source,xml, linenums]
----
<db:derby-config name="DerbyConfig"
 url="derbydatabase.com/MydatabaseTest"
 doc:name="Derby Configuration"/>
----

Notice in that `<db:derby-config />` in Mule 3 example above changes to `<db:config />` in the Mule 4 example below, and the attribute for the URL to the database changes from  `url` to `database` in Mule 4. The `<db:derby-connection />` element is new in Mule 4.

.Mule 4 Examples: Derby Configuration
[source,xml, linenums]
----
<db:config name="DerbyConfig" doc:name="Database Config"
 doc:id="280a5579-5490-4773-a36c-5e824def2370" >
  <db:derby-connection database="derbydatabase.com/MydatabaseTest" />
</db:config>

<db:config name="DerbyConfig">
   <db:derby-connection url="jdbc:derby:muleEmbeddedDB;create=true">
       <db:custom-data-types>
           <!-- Derby uses JAVA_OBJECT for UDT-->
           <db:custom-data-type typeName="CONTACT_DETAILS" id="2000"/>
       </db:custom-data-types>
   </db:derby-connection>
</db:config>
----

Note that additional `<db:derby-connection />` settings (XML attributes) specific to Derby are available in Mule 4:

* `create="true|false"`: Whether to create the database if it does not exist.
* `subsubProtocol="classpath"`: Type of SubsubProtocol to be used by Derby. The available options are `directory`, `memory`, `classpath` and `jar`.

=== Examples: Detailed Connector Configurations

These settings can be nested under all database connection configurations in Mule 4:

.Column Types
* Column types (`<db:column-types/>`) for non-standard column types.

.Pooling Profile
* Pooling profile (`<db:pooling-profile/>`) for JDBC Data Sources capable of connection pooling connections. It is is almost identical to Connection Pooling in Mule 3. An exception is the ...
// FROM SPEC: Pooling configuration for JDBC Data Sources capable of pooling connections. Notice that this is not Mule’s standard Pooling profile but a custom one targeted to data sources.

.Reconnection Strategies

Reconnection strategy (`<reconnection/>`) settings are similar in Mule 3 and Mule 4. However, custom reconnection strategies are not available in Mule 4.

The examples below show changes to the XML for these settings:

* None: Default. Same as Do Not Use A Reconnection Strategy in Mule 3.
* Standard: Same as Standard Reconnection in Mule 3. Both have the same options: Frequency (ms), Reconnection Attempts
* Forever: Same as Reconnect Forever in Mule 3.
+
.Mule 3 Examples: Reconnection Settings
[source,xml, linenums]
----
<db:mysql-config ...>
  <reconnect frequency="4000" count="4"/>`
</db:mysql-config>

<db:mysql-config ...>
  <reconnect-forever frequency="4000"/>`
</db:mysql-config>
----
+
.Mule 4 Examples: Reconnection Settings
[source,xml, linenums]
----
<db:mssql-connection ...>
  <reconnection failsDeployment="true">
    <reconnect frequency="4000" count="4"/>
  </reconnection>
</db:mssql-connection>

<db:mssql-connection ...>
  <reconnection >
    <reconnect-forever frequency="4000" />
  </reconnection>
</db:mssql-connection>
----

Only available in Mule 4:

* Fail Deployment When Test Connection Fails (`failsDeployment="true|false"`).

.Expiration Policies

Expiration policy (`<expiration-policy/>`) for idle configuration instances. Note that this element is a sibling of the database-specific configuration (such as `<db:oracle-connection />`) and is not nested under it.

.Mule 3 Example
----
TODO
----

.Mule 4 Example
----
TODO
----

=== Data Source Reference

.Mule 4 Example: Data Source Reference
[source,xml, linenums]
----
<db:data-source-connection dataSourceRef="data_source_ref_here" >
  <reconnection failsDeployment="true">
    <reconnect frequency="4000" count="4"/>
  </reconnection>
  <db:column-types >
    <db:column-type id="124"
     typeName="column_type"
     className="class_name" />
  </db:column-types>
  <db:pooling-profile maxPoolSize="6" minPoolSize="1"
   acquireIncrement="2" preparedStatementCacheSize="6"
   maxWait="1" maxWaitUnit="MINUTES" />
</db:data-source-connection>
----

This setting is unique to Data Source Reference:

* `dataSourceRef="my_ref_here"`: Reference to a JDBC DataSource object. This object is typically created using Spring. When using XA transactions, an XADataSource object must be provided.

.Mule 4 Example: Generic
[source,xml, linenums]
----
<db:config name="generic_connection" doc:name="Database Config"
 doc:id="a328feea-1b5e-4a14-b7dd-d457a76d56b5" >
  <reconnection />
  <db:column-types />
  <db:pooling-profile />
  <db:generic-connection url="url_here" driverClassName="driver_class_name_here" transactionIsolation="READ_COMMITTED" useXaTransactions="true"/>
  <expiration-policy maxIdleTime="30" timeUnit="SECONDS"/>
</db:config>
----

These setting are unique to a Generic database:

* `url="url_here"` for the JDBC URL to be used to connect to the database.
* `driverClassName="driver_class_name_here"` for the fully-qualified name of the database driver class.

These settings are available for Generic, Microsoft SQL Server, and Oracle connections:

* Transactions (for Generic, ) for the transaction isolation level to set on the driver when connecting the database.
 ** NOT_CONFIGURED (Default)
 ** READ_COMMITTED (`transactionIsolation="READ_COMMITTED"`)
 ** READ_UNCOMMITTED (`transactionIsolation="READ_UNCOMMITTED"`)
 ** REPEATABLE_READ (`transactionIsolation="REPEATABLE_READ"`)
 ** SERIALIZABLE (`transactionIsolation="SERIALIZABLE"`)
 ** Use XA Transactions (`useXaTransactions="true|false"`)

.Mule 4 Example: Microsoft SQL Server
[source,xml, linenums]
----
<db:config name="Microsoft_SQL_Server" doc:name="Database Config"
 doc:id="774cc10a-802c-43b1-aa90-7fca9a22fa83" >
  <db:mssql-connection host="my_host" user="myuser"
   password="mypassword" databaseName="mydatabase" >
    <reconnection />
    <db:column-types />
    <db:pooling-profile />
  </db:mssql-connection>
</db:config>
----

Microsoft SQL Server, MySql, Oracle configurations require a driver. T

.Example: Maven dependency setting for a Microsoft SQL Server driver
[source,xml, linenums]
----
<dependency>
  <groupId>com.microsoft.sqlserver</groupId>
  <artifactId>mssql-jdbc</artifactId>
  <version>6.2.2.jre8</version>
  <type>jar</type>
</dependency>
----

.Mule 4 Example: MySql
[source,xml, linenums]
----
<db:config name="MySQ" doc:name="Database Config"
 doc:id="27dba545-03f3-467a-8ccc-88dbbfca6b74" >
  <db:my-sql-connection host="myhost" user="myuser"
   password="mypassword" database="mydatabase" >
    <reconnection />
    <db:column-types />
    <db:pooling-profile />
  </db:my-sql-connection>
</db:config>
----

.Mule 4 Example: Oracle JDBC Database
[source,xml, linenums]
----
<db:config name="Oracle_Connection" doc:name="Database Config"
 doc:id="c307c37f-b02f-4f10-b0dd-6f1ea42feab2" >
  <db:oracle-connection host="myhost" user="myuser"
   password="mypassword" instance="myinstance" >
    <reconnection />
    <db:column-types />
    <db:pooling-profile />
  </db:oracle-connection>
  <expiration-policy />
</db:config>
----

Note that only some database connections provide these settings:

// TODO: I'M NOT SEEING CONNECTION PROPERTIES IN THE XML.
* Connection properties (`connectionProperties="my_expression_here"` on MySQL, Microsoft SQL Server only) for a list of custom key-value connection properties for the configuration.
 ** None (Default)
 ** Expression
 ** Inline
* Port (`port`) for non-standard ports. Otherwise, the connector uses the standard port by default.

[[database_operations_overview]]
== Database Connector Operations

In Mule 4, all database connector operations have a configurable display name, and all require reference to a connector configuration. They also provide a common set of settings:

* Query for SQL query text and input parameters (as shown here in <<database_operation_select>>).
* Streaming strategy settings (as shown here in <<database_streaming>>):
 ** None (Default)
 ** Non repeatable iterable ()
 ** Repeatable file store iterable (for  link://connectors/database-documentation#repeatable-file-store-iterable[maximum in-memory size and buffer unit settings])
 ** Repeatable in memory iterable (for link:/connectors/database-documentation#repeatable-in-memory-iterable[in-memory and buffer settings])
* Transactional action for the type of joining action that operations can take regarding transactions: ALWAYS_JOIN, JOIN_IF_POSSIBLE (Default), NON_SUPPORTED
* Query settings
* Target variable output settings
* Reconnection strategies
* Error mapping for errors, including DB:BAD_SQL_SYNTAX, DB:QUERY_EXECUTION
* Mule 4 input and output metadata for attributes, payload, and variables

[[database_parameterized_queries]]
=== Migrating Parameterized Queries

Operations like Select (`<db:select />`) retrieve information from the RDBMS.

* In Mule 3, you pass a parameterized query in `<db:parameterized-query />`.
* In Mule 4, they take an SQL query in `<database:sql />` and use DataWeave to supply the parameters through a sibling element, `<database:input-parameters>`.

Notice that this example uses the parameterized SQL query according to the Mule 3 model for accessing an inbound property.

.Mule 3 Example: SELECT
[source,xml, linenums]
----
<db:select config-ref="databaseConfig" doc:name="Database">
    <db:parameterized-query>
      <![CDATA[select first_name from employees where last_name = #[message.inboundProperties.'http.query.params'.lastname]]]>
    </db:parameterized-query>
</db:select>
----

Notice that the Mule 4 example uses `<database:input-parameters />` to specify the message attribute (`last_name`) used in the WHERE clause of the SQL query.

.Mule 4 Example: Select with a Parameterized Query
[source,xml, linenums]
----
<database:select config-ref="databaseConfig">
  <database:sql>
    select * from employees where last_name = :last_name
  </database:sql>
  <database:input-parameters>
    <![CDATA#[{'last_name' : payload}]]]>
  </database:input-parameters>
</database:select>
----

In Mule 4, input parameters are supplied as key-value pairs, which you can create by embedding a DataWeave script. Those keys are used with the semicolon character (`:`) to reference a parameter value by name. This approach is recommended to avoid SQL injection attacks, and it allows the connector to perform optimizations that improve the overall performance of the Mule app.

[[database_dynamic_queries]]
== Migrating Dynamic Queries

In Mule 3, operations such as Select (`<db:select />`) are split into parameterized and dynamic queries, and you cannot use both at the same time. You must choose between using a dynamic query or using parameters, which can provide SQL Injection protection, PreparedStatement optimization, and so on.

In Mule 4, the same set of operations, plus the Bulk operations () and Store Procedure, support DataWeave parameters to get results from dynamic queries:

* Select (`<db:select />`)
* Insert (`<db:insert />`)
* Update (`<db:update />`)
* Delete (`db:delete />`)
* Bulk operations: Bulk Insert (`<db:bulk-insert>`), Bulk Update (`<db:bulk-update>`), and Bulk Delete (`<db:bulk-delete>`)
* Stored Procedure (`<db:stored-prodedure />`): Mule 4 only

Sometimes you not only need to parameterize the WHERE clause but also to parameterize parts of the query itself. Use cases for this include queries that need to hit online or historic tables depending on a condition, or complex queries where the project columns need to vary.

.Mule 3 Example: SELECT with Parameterized Query
[source,xml, linenums]
----
<db:select config-ref="databaseConfig" doc:name="Database">
  <db:parameterized-query/>
</db:update>
----

.Mule 3 Example: SELECT with Dynamic Query
[source,xml, linenums]
----
<db:select config-ref="databaseConfig" doc:name="Database" >
  <db:dynamic-query/>
</db:select>
----

The Database Connector for Mule 4 can use both methods at the same time through expressions in the query. In the Mule 4 example, the expression produces the query by building a string in which the table depends on a variable. Notice that although the query text is dynamic, it still uses input parameters.

.Mule 4 Example
[source,xml, linenums]
----
<set-variable value="PLANET" doc:name="Set Variable"
 doc:id="9712c6fb-b9c2-4663-b3c7-d756c81f5444" variableName="table"/>
<db:select doc:name="Select"
 doc:id="9ea907ea-fd37-47b9-ad07-70c0521bac8d" config-ref="databaseConfig">
  <db:sql >SELECT * FROM $(vars.table) WHERE name = :name</db:sql>
  <db:input-parameters >
   #[{'name' : payload}]
  </db:input-parameters>
</db:select>
----

It is important to note that Input Parameters can only be applied to parameters in a WHERE clause.

////
Got a CDATA in 7.1 actually. Not sure if that's correct:
<![CDATA[{'name' : payload}]]>
Mariano's example here seems a bit out of date:
// TODO: IS THIS OUT OF DATE?
<set-variable variableName="table" value="PLANET"/>
<database:select config-ref="databaseConfig">
 <database:sql>#["SELECT * FROM $(vars.table) WHERE name = :name"]</database:sql>
 <database:input-parameters>
   #[{'name' : payload}]
 </database:input-parameters>
</database:select>
////
// TODO: SHOULD WE DISCUSS THE DW INTERPOLATION OPERATOR?

[[database_streaming]]
== Streaming Large Results

Database tables tend to be big. A single query might return tens of thousands of records, especially for integration use cases. Streaming is a great solution for this. What does streaming mean? Suppose you have a query which returns 10K rows. Attempting to fetch all those rows at once will result in the following:

* Performance degradation, since that’s a big pull from the network.
* A risk of running out of memory, since all that information needs to be loaded into RAM.

Streaming means that the connector will not fetch the 10K rows at once. Instead, it will fetch a smaller chunk, and once that chunk has been consumed it will fetch the rest. That way, you can reduce pressure over the network and memory.

In Mule 3.x this was something you had to specifically enable because it was disabled by default. In Mule 4, this is transparent and always enabled, you don’t have to worry about it anymore. You can simply trust that the feature is there.

.Mule 3 Example: Enabling Streaming
[source,xml, linenums]
----
<db:select config-ref="derby_config" doc:name="db Derby" streaming="true">
    <db:dynamic-query><![CDATA[my_dynamic_query_here]]></db:dynamic-query>
</db:select>
----

.Mule 4 Example: Streaming Automatically Enabled
[source,xml, linenums]
----
TODO: show example of same process without setting for enabling streaming
----

// NOTE: WHAT'S BELOW IS NEW AND DOES NOT HAVE A MIGRATION IMPACT, SO PROB NOT NEEDED
Another improvement from Mule 3 is that you can now use the new repeatable streams mechanism from Mule 4. That means that streams are now repeatable, and you can make DataWeave and other components process the same stream many times, even in parallel.

[[database_operation_bulk]]
=== Migrating Bulk Operations

In Mule 3, you set bulk functionality through a `bulkMode="true"` setting on Insert, Update, and Delete operations.

In Mule 4, you use dedicated Bulk Insert (`<db:bulk-insert>`), Bulk Update (`<db:bulk-update>`), and Bulk Delete (`<db:bulk-delete>`) database, instead. This means that operations no longer change their behavior depending on the received payload.

In Mule 3, you write the operation something like this:
[source,xml, linenums]
----
<db:insert config-ref="MySQL_Configuration"
 doc:name="db MySQL" bulkMode="true">
  <db:parameterized-query>
    <![CDATA[my_parameterized_query_here]]>
  </db:parameterized-query>
</db:insert>
----

In Mule 4, you might execute a bulk operation like this one:
.Mule 4 Example: Using the Bulk Operation to Get Different Values
[source,xml, linenums]
----
<db:bulk-insert config-ref="databaseConfig" >
  <db:sql>
    insert into customers (id, name, lastName) values (:id, :name, :lastName)
  </db:sql>
  <db:bulk-input-parameters>
    #[[{'id': 2, 'name': 'George', 'lastName': 'Costanza'}, {'id': 3, 'name': 'Cosmo', 'lastName': 'Kramer'}]]
  </db:bulk-input-parameters>
</db:bulk-insert>
----

== See Also

link:/connectors/database-documentation[Database Connector Documentation Reference]

link:migration-examples[Migration Examples]

link:migration-patterns[Migration Patterns]

link:migration-components[Migrating Components]
