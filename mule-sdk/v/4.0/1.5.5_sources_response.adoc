
[[_source_response]]
= Obtaining Flow output and Sending responses from a Message Source
:keywords: mule, sdk, sources, listener, triggers, response, output

One of the main properties of a Source is whether they generate a response or not.

Examples of sources which don’t emit a response are:

* A file listener
* Salesforce streaming API
* A scheduler element
* A source which listens for async push notifications

Sources that do emit a response

* A TCP Server
* An Http server
* A JMS server

As you can see, this classification is highly non deterministic. For example:

* Although an HTTP server supports sending a response, the user might choose not to
* Although a JMS listener might respond by sending a message to a reply queue, it might not depending on the message headers.
 
The concept that emerges from it is that the fact that a Source has the capability of sending a response, doesn’t necessarily 
imply that it will, even if the message was processed successfully. There’re logic or configuration circumstances which might
skip the response sending.

To specify that your source has the capability of generating the response, it must be annotated with `@EmitsResponse`.
Notice that this is just to tell the runtime and tooling that the source has the capability of doing so. 
However notice that the SDK nor the runtime will actually validate that:

* A source which emits response actually does so
* Prevent that a source which doesn’t declare itself to emit response sends one

== Callback parameters

Each time the flow is done processing a message generated by the source, the source might optionally 
need to obtain the response that the flow has generated. We do this through _callback methods_.
Callback methods are used to tap into the responses generated by the flow that owns the source. We can do 
this by declaring methods annotated with `@OnSucess` , `@OnError` and `@OnTerminate`. These methods are 
declared in a similar fashion as operations, but they need to be void, since they listen for the response 
but cannot alter it.

Each of the parameters in these callback methods will be evaluated in the same manner as operations 
(including auto transformation). Notice however that because these callback are executed in response to 
the runtime processing a message, these CAN actually accept expressions and will by default.

[TIP]
Even if the source doesn’t emit responses, it might still want to have callback methods. They might still be 
needed for releasing resources, logging, auditing, etc.

== Listening for Successsful Outputs

The source can optionally declare one method annotated with `@OnSuccess` and such method will be executed 
when the flow successfully processes the message (either because no errors were thrown or because they were 
all handled gracefully).

This method can have arguments which will be treated as source parameters. Notice that the end user who is 
actually using this connector cannot tell the difference (and doesn't need to either) between a regular parameter 
and a callback one. For him it's all the same and tooling (Studio or Flow Designer) will tell him which parameters 
accept expressions and which ones doesn't. The user should not need to worry about anything else.

Another important thing to keep in mind is that, as explained in a previous article, the processing of the message 
once the source has pushed it to the flow is asynchronous. That also means that the `@OnSuccess` method will also 
be invoked asynchronously. 

Let's see another oversimplified example from the Http connector:

[source, java]
----
@EmitsResponse <1>
public class HttpListener extends Source<InputStream, HttpRequestAttributes> {

    @Override
    public void onStart(SourceCallback<InputStream, HttpRequestAttributes> sourceCallback) throws MuleException {
        httpServer = serverProvider.connect(); 
        
        server.listen(path).onRequest(request -> { 
            SourceCallbackContext ctx = sourceCallback.createContext(); // <2>
            ctx.setVariable("responseContext", new HttpResponseContext(request.getResponseSender()); // <3>
            Result<InputStream, HttpRequestAttributes> result = requestToResult(request); 
            sourceCallback.handle(result, ctx); // <4>
        }); 
    }

    @OnSuccess
    public void onSuccess(@Content String responseBody,
                    @Optional responseStatusCode,
                    SourceCallbackContext callbackContext // <5>
                    ) throws Exception {
        if (hasResponse(responseStatusCode)) { // <6>
            HttpResponseContext responseContext = callbackContext.getVariable("responseContext"); // <7>
            responseContext.sendResponse(responseBody, statusCode); <8>
        }
    }
}
----

<1> First we annotate the source with `@EmitsResponse`, since the HttpListener is one that might send a response
<2> Because the `@OnSuccess` method is invoked asynchronously (and most likely in parallel), we need to communicate 
state to the callback method. Most precisely, we need to provide some kind of reference regarding the actual request 
that we will reply into. To that, we create a new `SourceCallbackContext` using the `SourceCallback`
<3> We add a variable into the context which holds an `HttpResponseContext`. This is a custom object defined in the 
connector which knows how to send responses
<4> We generate and push the message through the `SourceCallback`, using both the `Result` object and the newly 
create context.
<5> The callback method has two parameters, a `@Content` one which is the body of the response to be sent and the 
HTTP status code of the response. There's a third argument of type `SourceCallbackContext`. This is not an actual 
parameter but a way to tell the SDK that we want to recover the same context that was passed to the `handle()` method. 
<6> Because the Http protocol not always sends a response, we check if the response status code requires the response 
to be sent or not.
<7> If we do need a response, we recover the response context that was originally set on the context
<8> Finally, we send the response

== Listening for Error Outputs

Similar to `@OnSuccess`, the `@OnError` will be executed when an unhandled error is thrown by the flow.

The following example taken from the http connector shows how the success callback method can:

Similarly to the example above:

[source, java]
----
@OnError
public void onError(
                   @Optional @DisplayName(ERROR_RESPONSE_SETTINGS) @NullSafe HttpListenerErrorResponseBuilder errorResponseBuilder,
                   SourceCallbackContext callbackContext,
                   Error error) {

}
----

In this case, the method is very similar to the success one. It also receives parameters, the callback context 
and will send an error response back to the requester. But it can also receive an Error object. 
This is the actual Mule Error object which contains the information about the actual failure that was catched.

[TIP]
The `Error` object is not a Java `java.lang.Error` object but an SDK `org.mule.runtime.api.message.Error`

== Content parameters

The callbacks accept content parameters just like any operation. In the case of the http connector, 
it makes sense for the HttpListenerResponseBuilder to use them to allow the use of DataWeave into 
transforming the flow’s result into whatever format that the connector intends to return. 
All the concepts of content and primary contents apply, as well as their associated restrictions.

== On Terminate

A source is not required to provide both `@OnSuccess` and `@OnError` methods. They can just declare the ones they need or 
none at all. But if at least one of them is defined, then you also need to define an `@OnTerminate` method.

Why is this required? Because either the `@OnSuccess` and `@OnError` might fail. If for whatever reason, any of 
them throw an exception, a remote system might be left hung waiting for a response, resources might leak, audit 
logs might be left uncomplete, etc.

An example onTerminate method looks like this:

[source, java]
----
  public void onTerminate(SourceResult sourceResult) {
    Boolean sendingResponse = (Boolean) sourceResult.getSourceCallbackContext().getVariable(RESPONSE_SEND_ATTEMPT).orElse(false);
    if (FALSE.equals(sendingResponse)) {
      sourceResult
          .getInvocationError()
          .ifPresent(error -> sendErrorResponse(new HttpListenerErrorResponseBuilder(),
                                                sourceResult.getSourceCallbackContext(),
                                                error,
                                                null));
    }
  }
----

The method receives a `SourceResult` object which contains optional errors that might have occurred in either 
the onSucess or onError methods and the associated `SourceCallbackContext`.

In the example above, the method sends a generic error response in case an error was found

== Next step

* <<_source_async_response, Sending asynchronous responses from a Message Source>>