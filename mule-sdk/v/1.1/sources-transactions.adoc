
= Transactional Message Sources
:keywords: mule, sdk, sources, listener, triggers, transactions

Just like operations, Message Sources support transactions. Example of this are the JMS and VM connector listeners.
Both listeners take messages out of a queue and push it to a Flow. If the processing of that message is successful,
then the transaction is committed. Otherwise, the transaction is rolled back and the message goes back to the queue.

Just like with operations, for a Message Source to be transactional, it just needs to operate over a connection
type which implements the `TransactionalConnection` interface. XA transactions are also automatically supported if
the connection implements `XATransactionalConnection`.

For example:

[source, java, linenums]
----
public class TransactionalSource extends Source<Serializable, Void> {

  @Connection
  private ConnectionProvider<MyTransactionalConnection> connectionProvider;

  ....
}
----

== Message Source Transactional Actions

When a Message Source is transactional, a synthetic parameter named `transactionalAction` is automatically
added to it. That parameter is an enum type which can take 2 possible values:

* ALWAYS_BEGIN: Will ensure that a new transaction is created for each invocation
* NONE: The source will not start any transaction and will not participate of one opened in the Flow

== Message Source Transaction Types

Also, when the source supports XA transactions, a `transactionType` parameter is also added which can take
two possible values:

* LOCAL: Starts a regular transaction
* XA: Starts a XA transaction instead

== Handling Transactions

Because in the SDK transactions are modeled through Connections, each individual transaction require a different
connection instance. This is because Message Sources need to support parallelism and the same connection cannot be
serving two different transactions at the same time.

This requires a model different from that of the Http Listener example we've been working with. So let's consider
another oversimplified example, the `<vm:listener />` from the VM Connector:

[source, java, linenums]
----
public VMListener extends Source<Serializable, VMMessageAttributes> {

	@Connection
	private ConnectionProvider<QueueSession> sessionProvider;

	@Override
  public void onStart(SourceCallback<Serializable, VMMessageAttributes> sourceCallback) throws MuleException {
		while(notStopped()) {
			QueueSession session =  sessionProvider.connect(); // <1>
      CallbackContext ctx = callback.createContext(); // <2>
			TransactionHandle status = ctx.bindConnection(session); // <3>

			try {
				callback.handle(session.poll(), ctx); // <4>
			} catch (Exception e) {
				status.rollback();
			}
		}
	}

	@OnSuccess
	public void onSuccess(SourceCallbackContext context) {
		handleSuccess(context.getConnection()); // <5>
	}

	@OnError
	public void onError(SourceCallbackContext context, Error error) {
		handleError(context, error);
	}
}
----


<1> Multiple connections are obtained
<2> For each connection, a new CallbackContext is created
<3> Each connection is registered with the context through the bindConnection() method in the `SourceCallbackContext`
that was just created.
<4> The context is passed to the handle method
<5> The connection will later be available for all the onSuccess, onError and onTerminate methods, through the SourceCallbackContext.getConnection() method

Because the connection has been bound to the context, the runtime will automatically close the connection when needed.
If the connection is transactional and the source is configured to be transactional as well, calling the
`bindConnection()` method will automatically start the transaction on that connection. Also if transactional,
the runtime will automatically commit the transaction after the `onSuccess()` method or roll it back after the
`onError()` method.

[TIP]
Notice that in this case, we want the transaction to be started BEFORE we tried to poll any message from the queue.
Good practice is to call the bindConnection() immediately after the connection has been obtained.

== Custom transaction handling

Some connectors may want to have custom transaction handling. For example, suppose that in case of error, we
want to publish an error response. In that case, we need the tx to be committed, because if it were rolled back,
then the response would never reach it's destination.

Example:

[source, java, linenums]
----

  @OnError
	public void onError(SourceCallbackContext context, Error error) {
		ctx.getConnection().publish(buildErrorResponse(error)); // <1>
		ctx.getTransactionHandle().commit(); // <2>
	}
----

Take aways:

<1> The connection is still in an open state when the `onSuccess()` and `onError()` methods are executed
<2> The context has a TransactionHandle which allows you to manually manipulate the transaction. If you
manually resolve the transaction, the runtime will respect your wishes and not do it for you later. You don't
need to do this on the most common use cases
