= DataWeave value types
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping


The link:/mule-user-guide/v/4.0/dataweave[DataWeave] language functions essentially as a template engine that describes an output structure through the use of elements that may be of various different types.

== Array

An array is a sequence of elements.

.Example
[source,DataWeave,linenums]
----
%dw 2.0
output application/json
var x = "words"
---
[ "My", "three", x ]
----


=== Conditional Elements

Arrays can define elements that appear or don't, based on a condition.

Conditional elements have the form `(value) if condition`


.Transform
[source,DataWeave,linenums]
----
%dw 2.0
output application/json
---
[(1) if true, (2) if false]
----

.Output
[source,json,linenums]
----
[1]
----

== Object

An object is a sequence of `key:value` pairs.

.Example

[source,DataWeave,linenums]
---------------------------------------------------------
%dw 2.0
output application/json
---
{
  name: "Annie"
}
---------------------------------------------------------

=== Single Value Objects

If an Object has only one `key:value` pair, the enclosing curly brackets { } are not required:

.Example

[source,DataWeave,linenums]
---------------------------------------------------------
%dw 2.0
output application/json
---
name: "Annie"
---------------------------------------------------------

=== Conditional Elements

Objects can define conditional *key*: *value* pairs based on a conditional expression.
Conditional elements have the form `(key:value) if condition`

[source,DataWeave,linenums]
---------------------------------------------------------
%dw 2.0
output application/xml
---
file: {
  name: "transform",
  (extension: "zip") if payload.fileSystem?
}
---------------------------------------------------------

This example outputs an additional field called "extension" only when the fileSystem property is present in payload (this field may contain any value, not just `true`).

[source,xml,linenums]
--------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<file>
  <name>transform</name>
  <extension>zip</extension>
</file>
--------------------------------------------------------

If absent:

[source,xml,linenums]
--------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<file>
  <name>transform</name>
</file>
--------------------------------------------------------

=== Dynamic Keys

In order to specify a key via an expression, the expression should be wrapped in parentheses.

.Transform
[source,DataWeave,linenums]
----
%dw 2.0
output application/json
var dynamicKey = "language"
---
{
  (dynamicKey): "Data Weave"
}
----

.Output
[source,json,linenums]
----
{
  "language": "Data Weave"
}
----

=== Dynamic Elements

Dynamic elements allow you to add the result of an expression as `key:value` pairs of an object. That expression must be either an `object` or an `array of objects`.

.Transform
[source,DataWeave,linenums]
--------------------------------------------------------
%dw 2.0
output application/json
var x = [
  {b: "b"},
  {c: "c", d: "d"}
],
var y = {e: "e"}
---
{
  a: "a",
  (x),
  (y)
}
--------------------------------------------------------

.Output
[source,json,linenums]
--------------------------------------------------------
{
  "a": "a",
  "b": "b",
  "c": "c",
  "d": "d",
  "e": "e"
}
--------------------------------------------------------



=== Conditional Attributes

Attributes can define elements that appear or don't, based on a condition.
Conditional elements have the form `(key:value) if condition`

.Transform
[source,DataWeave,linenums]
----
%dw 2.0
output application/xml
---
{
  name @(
    (company: "Acme") if false,
    (transform: "Anything") if true
  ): "DataWeave"
}
----

.Output
[source,xml,linenums]
----
<?xml version='1.0' encoding='US-ASCII'?>
<name transform="Anything">DataWeave</name>
----

=== Dynamic Attributes

Dynamic attributes allow you to add the result of an expression as `key:value` pairs of the attributes set.

.Input
[source,json,linenums]
----
{
  "company": "Mule",
  "product": "DataWeave"
}
----

.Transform
[source,dataweave,linenums]
----
%dw 2.0
output application/xml
---
transformation @((payload)): "Transform from anything to anything"
----

.Output
[source,xml,linenums]
----
<?xml version='1.0' encoding='US-ASCII'?>
<transformation company="Mule" product="DataWeave">Transform from anything to anything</transformation>
----

== String

A string can be defined by the use of double quotes or single quotes.

[source,DataWeave, linenums]
--------------------------------------------------------
{
  doubleQuoted: "Hello",
  singleQuoted: 'Hello',
}
--------------------------------------------------------

=== String Interpolation

String interpolation allows you to embed variables or expressions directly in a string.

.Transform
[source,DataWeave, linenums]
--------------------------------------------------------
%dw 2.0
output application/json
var name = "Shoki"
---
{
    Greeting: "Hi, my name is $name",
    Sum: "1 + 1 = $(1 + 1)"
}
--------------------------------------------------------

.Output
[source,json,linenums]
--------------------------------------------------------
{
  "Greeting": "Hi, my name is Shoki",
  "Sum": "1 + 1 = 2"
}
--------------------------------------------------------

== Number

There is only one number type that supports both floating point and integer numbers.
There is no loss of precision in any operation, the engine always stores the data in the most performant way that doesn't compromise precision.

== Boolean

A boolean is defined by the keywords `true` and `false`.


== Dates

Dates in DataWeave follow the link:https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[ISO-8601 standard] and literals are defined between '|' characters.

The language has the following native date types:

* DateTime
* LocalDateTime
* Time
* LocalTime
* Period
* TimeZone
* Date


=== Date

Specified as `|YYYY-MM-dd|`

The type *Date* has no time component at all (not even midnight).


.Example
[source,DataWeave, linenums]
-----------------------------------------------------------------
|2003-10-01|
-----------------------------------------------------------------

=== Time

Specified as `|HH:mm:ss.SSS|`


.Example
[source,DataWeave, linenums]
-----------------------------------------------------------------
|23:59:56|
-----------------------------------------------------------------


=== TimeZone

TimeZones must include a + or a - to be defined as such. |03:00| is a time, |+03:00| is a timezone.


.Example
[source,DataWeave, linenums]
-----------------------------------------------------------------
|-08:00|
-----------------------------------------------------------------


=== DateTime

DateTime is the conjunction of 'Date' + 'Time' + 'TimeZone'.

.Example
[source,DataWeave, linenums]
-----------------------------------------------------------------
|2003-10-01T23:57:59-03:00|
-----------------------------------------------------------------

=== LocalDateTime

LocalDateTime is the conjunction of 'LocalDate' + 'Time'.

.Example
[source,DataWeave, linenums]
-----------------------------------------------------------------
|2003-10-01T23:57:59|
-----------------------------------------------------------------

=== Period

Periods have the form:

- `P[n]Y[n]M[n]DT[n]H[n]M[n]S`
- `P<date>T<time>`

Where the [n] is replaced by the value for each of the date and time elements that follow the [n].

`P` is the duration designator placed at the start of the duration representation.

- `Y` is the year designator (e.g. `|P1Y|`)
- `M` is the month designator (e.g. `|P1M|`)
- `D` is the day designator (e.g. `|P1D|`)

`T` is the time designator that precedes the time components of the representation.

- `H` is the hour designator (e.g. `|PT1H|`)
- `M` is the minute designator (e.g. `|PT1M|`)
- `S` is the second designator (e.g. `|PT1S|`)

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------
%dw 2.0
output application/json
---
a: |20:00:00| + |PT1M1S|
----------------------------------------------------------------

.Output
[source,json,linenums]
----------------------------------------------------------------
{
  "a": "20:01:01"
}
----------------------------------------------------------------


=== Date Decomposition

In order to access the different parts of the date, special selectors must be used.

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 2.0
output application/json
var myDate = |2003-10-01T23:57:59.700-03:00|
---
{
  year: myDate.year,
  month: myDate.month,
  day: myDate.day,
  hour: myDate.hour,
  minutes: myDate.minutes,
  seconds: myDate.seconds,
  milliseconds: myDate.milliseconds,
  nanoseconds: myDate.nanoseconds,
  quarter: myDate.quarter,
  dayOfWeek: myDate.dayOfWeek,
  dayOfYear: myDate.dayOfYear,
  offsetSeconds: myDate.offsetSeconds
}
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "year": 2003,
  "month": 10,
  "day": 1,
  "hour": 23,
  "minutes": 57,
  "seconds": 59,
  "milliseconds": 700,
  "nanoseconds": 700000000,
  "quarter": 4,
  "dayOfWeek": 3,
  "dayOfYear": 274,
  "offsetSeconds": -10800
}
-----------------------------------------------------------------

=== Changing the Format of a Date

You can specify a date to be in any format you prefer through using *as* in the following way:

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------
%dw 2.0
output application/json
---
formattedDate: |2003-10-01T23:57:59| as String {format: "YYYY-MM-dd"}
----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "formattedDate": "2003-10-01"
}
-----------------------------------------------------------------

If you are doing multiple similar conversions in your transform, you might want to define a custom type as a directive in the header and set each date as being of that type.

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------
%dw 2.0
output application/json
type Mydate = String { format: "YYYY/MM/dd" }
---
{
  formattedDate1: |2003-10-01T23:57:59| as Mydate,
  formattedDate2: |2015-07-06T08:53:15| as Mydate
}
----------------------------------------------------------------


.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "formattedDate1": "2003/10/01",
  "formattedDate2": "2015/07/06"
}
-----------------------------------------------------------------

[NOTE]
Type names are case-sensitive.

== Regex

Regular Expressions are defined between `/`. For example `/\d+/` represents multiple numerical digits from 0-9.
These may be used as arguments in certain operations that act upon strings, like Matches or Replace, or on operations that act upon objects and arrays, such as filters.

== Iterator

This type is based in the link:https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html[iterator Java class], that iterates through arrays. The iterator contains a collection, and includes methods to iterate through and filter it.

[NOTE]
Just like the Java class, the iterator is designed to be consumed only once. For example, if you then pass this value to a link:/mule-user-guide/v/4.0/logger-component-reference[logger] would result in consuming it and it would no longer be readable to further elements in the flow.



== Enum

This type is based in the link:https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html[Enum java class].
It must always be used with the `class` property, specifying the full java class name of the class, as shown in the example below.

.Transform
[source,DataWeave, linenums]
----
%dw 2.0
output application/java
---
"Male" as Enum {class: "com.acme.GenderEnum"}
----

== CData


The link:/mule-user-guide/v/4.0/dataweave-types#xml[XML format] defines a custom type named CData, it extends from string and is used to identify a CDATA XML block.
It can be used to tell the writer to wrap the content inside CDATA or to check if the input string arrives inside a CDATA block. `CData` inherits from the type `String`.

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------------
%dw 2.0
output application/xml
---
{
users:
{
user : "Mariano" as CData,
age : 31 as CData
}
}
----------------------------------------------------------------------

.Output
[source,xml,linenums]
----------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<users>
<user><![CDATA[Mariano]]></user>
<age><![CDATA[31]]></age>
</users>
----------------------------------------------------------------------




== Custom Types

You can define your own custom types in the header of your transform, then in the body you can define an element as being of that type.

To do so, the directive must be structured as following: `type name = java definition`

For example:

[source,DataWeave,linenums]
----
%dw 2.0
type Currency = Number { format: "##"}
type User = Object { class: "my.company.User"}
----

[TIP]
====
Usually it's a good idea to extend an existing type rather than creating one from scratch.

For example, above `String` defines `Currency` as extending the String type.
====

To then assign an element as being of the custom type you defined, use the operation `as Type` after defining a field:

[source,DataWeave,linenums]
----
%dw 2.0
type Currency = Number { format: "##"}
type User = Object { class: "my.company.User"}
---
customer: payload.user as User
----


=== Defining Types For Type Coercion


==== Format

The metadata 'format' key is used for formatting numbers and dates.

.Input
[source,xml,linenums]
-----------------------------------------------------------------------
<items>
    <item>
        <price>22.30</price>
    </item>
    <item>
        <price>20.31</price>
    </item>
</items>
-----------------------------------------------------------------------

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------------
%dw 2.0
output application/json
type Currency = Number { format: "##"}
---
books: payload.items.*item map
    book:
        price: $.price as Currency
-----------------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------------
{
  "books": [
    {
      "book": {
        "price": 22.30
      }
    },
    {
      "book": {
        "price": 20.31
      }
    }
  ]
}
-----------------------------------------------------------------------

In Anypoint Studio, you can define several more values, like separators, quote characters and escape characters. See link:/anypoint-studio/v/6/using-dataweave-in-studio#configuring-the-csv-reader[Using DataWeave in Studio].



== Functions and Lambdas

In DataWeave, function and lambdas (anonymous functions) are first-class citizens and they can be passed as values or be assigned to variables.
When using lambdas within the body of a DataWeave file in conjunction with an operator such as link:/mule-user-guide/v/4.0/dataweave-core-functions#map[map operator], its attributes can either be explicitly named or left anonymous, in which case they can be referenced as $, $$, etc.


=== Declaring a Function

You can declare functions in the Header and these can be invoked at any point in the Body, you can also declare functions anywhere in the body. You refer to them using the form *functionName()* passing an expression in between the parentheses for each necessary argument. Each expression between the parentheses is evaluated and the result is passed as an argument used in the execution of the function body.

.Input
[source, json,linenums]
----
{
  "field1": "Annie",
  "field2": "Point",
  "field3": "Stuff"
}
----

.Transform
[source,DataWeave, linenums]
----
%dw 2.0
output application/json
fun toUser(obj) = {
  firstName: obj.field1,
  lastName: obj.field2
}
---
{
  "user" : toUser(payload)
}
----

.Output
[source, json,linenums]
----
{
  "user": {
    "firstName": "Annie",
    "lastName": "Point"
  }
}
----

=== Assigning a Lambda to a Var

You can define a function as a variable with a link:/mule-user-guide/v/4.0/dataweave-language-introduction#define-constant-directive[constant directive] through 'var'

.Input
[source,json, linenums]
----
{
  "field1": "Annie",
  "field2": "Point",
  "field3": "Stuff"
}
----

.Transform
[source,DataWeave, linenums]
----
%dw 2.0
output application/json
var toUser = (obj) -> {
  firstName: user.field1,
  lastName: user.field2
}
---
{
  "user" : toUser(payload)
}
----

.Output
[source, json,linenums]
----
{
  "user": {
    "firstName": "Annie",
    "lastName": "Point"
  }
}
----

=== Named Parameters in a Lambda

This example uses a lambda with an attribute that's explicitly named as 'name'.

.Input
[source,DataWeave, linenums]
---------------------------------------------------------------------
%dw 2.0
output application/json
var names = ["john", "peter", "matt"]
---
users: names map ((name) -> upper name)
---------------------------------------------------------------------

.Transform
[source,json,linenums]
---------------------------------------------------------------------
{
  "users": ["JOHN","PETER","MATT"]
}
---------------------------------------------------------------------

=== Anonymous Parameters in a Lambda

This example uses a lambda with an attribute that's not explicitly named, and so is referred to by default as '$'.

.Transform
[source,DataWeave, linenums]
---------------------------------------------------------------------
%dw 2.0
output application/json
var names = ["john", "peter", "matt"]
---
users: names map upper $
---------------------------------------------------------------------

.Output
[source,json,linenums]
---------------------------------------------------------------------
{
  "users": ["JOHN","PETER","MATT"]
}
---------------------------------------------------------------------




== Type Coercion Table

In DataWeave, types can be coerced from one type to other using the link:/mule-user-guide/v/4.0/dataweave-core-functions#as[AS Operator].
This table shows the possible combinations and the properties from the schema that are used in the transformation.

[TIP]
When you <<DataWeave Operators Sorted by Type, provide an operator>> with properties that don't match the expected types, DataWeave automatically attempts to coerce the provided property to the required type.

|====
|Source                         |Target                 | Property
|Range                          |Array                  |
|Number                         |Binary                 |
|String                         |Binary                 |
|String                         |Boolean                |
|Number                         |DateTime               | unit
|LocalDateTime                  |DateTime               |
|String                         |DateTime               | format / locale
|DateTime                       |LocalDate              |
|LocalDateTime                  |LocalDate              |
|String                         |LocalDate              | format / locale
|DateTime                       |LocalDateTime          |
|String                         |LocalDateTime          | format / locale
|DateTime                       |LocalTime              |
|LocalDateTime                  |LocalTime              |
|Time                           |LocalTime              |
|String                         |LocalTime              | format / locale
|DateTime                       |Number                 | unit
|String                         |Number                 | format / locale
|String                         |Period                 |
|String                         |Regex                  |
|DateTime                       |String                 | format / locale
|LocalDateTime                  |String                 | format / locale
|LocalTime                      |String                 | format / locale
|LocalDate                      |String                 | format / locale
|Time                           |String                 | format / locale
|Period                         |String                 |
|TimeZone                       |String                 |
|Number                         |String                 | format / locale
|Boolean                        |String                 |
|Range                          |String                 | (2)
|Type                           |String                 |
|DateTime                       |Time                   |
|LocalDateTime                  |Time                   |
|LocalTime                      |Time                   |
|String                         |Time                   | format
|DateTime                       |TimeZone               |
|Time                           |TimeZone               |
|String                         |TimeZone               |
|====


<1> Returns an array with all the values of the object.
<2> Returns a string with all the values of the range using "," as the separator


== See Also

* For a high level overview about the language, see link:/mule-user-guide/v/4.0/dataweave-language-introduction[DataWeave Language Introduction]
* For a reference about all of the operators that are available for using, see link:/mule-user-guide/v/4.0/dataweave-core-functions[DataWeave Core Functions]
* View complete example projects that use DataWeave in the link:https://www.mulesoft.com/exchange#!/?filters=DataWeave&sortBy=rank[Anypoint Exchange]
