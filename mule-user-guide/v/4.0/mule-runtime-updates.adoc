= Mule Runtime v4 Updates
:keywords: news, updates, mule ESB, mule runtime, 4.0, Mule 4.0, Mule 4.0 for mule 3 developers, what's new Mule 4

Mule 4 introduces significant changes from previous versions. +
Its simplified language and reduced management complexity allows you to speed up the on ramping process and deliver applications faster.

If you are familiar with the concepts of the previous versions of the runtime, check the sections below to learn what's changing in Mule Runtime v4.0:

== Simplified Event and Message Model

Mule 4 includes a simplified Mule Event and Message model. In Mule 4, Flows are triggered by an Event. An Event has a Message and variables associated with it. A Message is composed of a payload and its attributes (metadata, such as files size). Variables hold arbitrary information, such as Messages, payload data, or attributes.

All other concepts around the former Mule Event object have been deprecated:

* There are no more _inbound_, _outbound_ or _session_ properties.
* To send data across protocol barriers like session properties did, you must explicitly specify what parameters you want to send. For example with the HTTP request, you can specify output headers.
* All information around the Mule event is now exposed through variables, allowing you to completely manage the Mule event.

The steps in the flow that handle Mule events, are now referred to as components. Components that act on a Mule Event are event processors, and every processor that defines an operation to apply to the Mule event are known as operations. Once operations execute, they replace the Message on the Event with a new one. To save the previous message, you must store it in a variable

== DataWeave 2.0: the new Mule Expression Language

In Mule 3, users had to contend with learning both the Mule Expression Language (MEL) and DataWeave. MEL forces users to convert their payloads from binary data, such as XML or JSON documents, into Java objects, so they can write expressions which access that data, for example when routing it to a specific location.

In *Mule 4*, DataWeave is now the default expression language. Combined with the built-in streaming capabilities, this simplifies many common tasks:

* Events can be routed based on payload data, without first needing to convert to Java objects.
* Binary data can easily be queried from an expression anywhere in your flow, for example, when logging.
* Larger than memory access to data happens transparently.

DataWeave 2.0 also features many improvements:

* Language simplifications. Everything is now a function.
* DataWeave scripts can now be packaged and reused, via the new imports and modules features.
* Support for multi-line comments.
* Support for calling static Java functions directly from DataWeave.

== Streaming management

// COMBAK - link to streaming section in docs
// Current draft: https://github.com/mulesoft/mulesoft-docs/blob/streaming-patch/mule-user-guide/v/4.0/streaming-about.adoc (needs review).
Mule 4 automatically handles data streams for users. This greatly simplifies working with data in the runtime because:

* Data can be read multiple times or accessed randomly with the DataWeave expression language without side effects.
* Data can be sent to multiple places, without the user caching that data in memory first.
* Users can transparently access larger than memory data.

== Non-Blocking, Self-Tuning Runtime

Mule 4 includes a new execution engine that is based on a non-blocking runtime. This is a task-oriented execution model allowing you to take advantage of non-blocking IO calls and avoiding performance problems due to incorrect processing strategies configurations.

As a result of this new engine, you no longer have to configure exchange patterns. Instead, flows always function synchronously. If you wish to achieve asynchronous type patterns such as fire and forget, you can use the <async> processor.

Each Mule event processor can now inform the runtime if it is a CPU intensive, CPU light, or IO intensive operation. This helps in turn for the runtime to self-tune for different workloads dynamically, removing the need for you to manage thread pools manually. As a result, Mule 4 removes complex tuning requirements to achieve optimum performance.

== Enrich Events directly from connectors/modules

For any given module operation, it is now possible to define a target, which saves the result in a variable:

[source,XML,linenums]
----
<httpn:request target="myVar" config-ref="requestConfig" method="GET" url="http://mulesoft.com"/>
----

This saves the Mule message in the myVar variable to be accessed later. This reduces flow complexity by removing the need for enricher.

== Simplified Connectors and Modules Experience

Mule 4 introduces more consistency around modules and connectors, creating one unified experience for how to interact with Mule components. +
Transports have been completely replaced by Mule Modules. Modules and connectors can be created and managed using the Mule SDK, which provides a single way to extend Mule.

// COMBAK: Smart connectors are not going to be available for BETA
// Introducing Smart Connectors: Modules designed using XML to manipulate connections. +
// Users can define the module, set configurations and define operations that can later be invoked in the mule application to manipulate connections.

// REVIEW: Need confirmation about private flows going away.

== Simplified Error Handling and new Try Scope

Mule 4 includes a simplified way to manage errors. Instead of dealing with Java Exceptions directly, there is now an Error concept build directly into Mule. Furthermore, Mule Modules and Connectors declare what Errors may occur for any given operation. This makes it easy for you to discover possible errors at design time and catch them.

Exception strategies are replaced by error handlers allowing you to catch errors based on both type, and arbitrary expressions. +
You can configure your error handlers to catch errors so that the flow can keep processing, or they can be re-propgated.

There is also a new Try Scope, This allows you to catch errors in the middle of a flow, without having to create a new flow, specifically to catch that error.

== Mule API

Mule 4 includes new, well defined APIs. These make it easier for you to extend Mule and provides clarity on what the proper extension points are.

The runtime exposes 3 main APIs that allow you to build on top and extend the runtime capabilities:

* Core API: Mule message.
* Extensions API: APIs which allow you to create modules, message processors, transformers, etc. to extend the runtime.
* Tooling API: All DataSense metadata and propagation is now part of the runtime, and can be accessed as part of the tooling API, which is bundled with the Mule Agent.

== Classloader Isolation for Mule runtime, Applications, and connectors

Mule 4 loads each Module in its own classloader, isolating the modules from internal Mule code. +
Given that applications are no longer dependent from internal Mule changes, you are now able to upgrade your runtime version without breaking compatibility with other modules.

All modules are distributed outside the runtime, meaning that Mule 4 does not include any connector by default.

== Compatibility Module

To help you migrate to Mule 4, there is a new compatibility module which provides backward compatibility for a number of features from Mule 3, including:

* Transports: HTTP, JMS, Database.
* Mule Expression Language.
* set-payload, set-variable, set-property, remove-property, copy-properties.
* poll.

// COMBAK link to the migration guide

